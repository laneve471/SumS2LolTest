#include <iostream>

using namespace std;

#pragma region 컴퓨터 이론
// CPU
// - 레지스터 : 연산에 쓰일 임시값
// - 캐시 : 
//  -- 가장 최근에 접근했던 주소값은 또 다시 쓰일 경우가 경우가 높다.
//  -- 가장 빈번하게 접근했던 주소값은 또 다시 쓰일 경우가 높다.

// C++ 컴파일 4단계
// 1. 전처리기 (매크로, #, 주석) 
// 2. 컴파일러 (C++(고수준) 언어를 어셈블리어(저수준)로 변환) => 변환할 수 없으면 컴파일 에러
// 3. 어셈블리어 : 저수준 언어를 기계어로 바꿈. (obj파일 생성)
// 4. 링커 : 파일결합, 실행파일 생성

// 메모리(RAM) 4영역
// - CODE : 코드 저장
// - DATA : 전역변수(Global), 정적변수(Static)
// - STACK : 지역변수(Local), 매개변수(Parameter, Arrgument), 반환주소값(Return ptr)
// - HEAP : 사용자의 영역
#pragma endregion

// Datatype : 자료형
// 데이터를 저장할 건데, 어떤 방식으로 표기하고, 표현할 것이냐, 크기는 어떻게 할 것이냐

// bit : 컴퓨터가 계산할 수 있는 가장 작은 단위
// 0,1 ... 표현할 수 있는 경우의 수 2

// Byte : 8bit
// 표현할 수 경우의 수 : 2^8

// - 정수형
// short
// 크기 : 2바이트(-2^15 ~ 2^15 -1) -32768 ~ 32767
short aShort = 1;

// int
// 크기 : 4바이트(-2^31 ~ 2^31 - 1) -21억 ~ 21억

// __int64
// 크기 : 8바이트(-2^63 ~ 2^63 -1)

// - 부호(비트)가 없는 정수형
// unsinged short : 2바이트(0 ~ 2^16)
unsigned short u_aShort = 3;

// (정수형 음수)2의 보수법
// 1. 모든 비트를 거꾸로 뒤집는다.
// 2. +1한다

// 문자형 : 문자도 사실 정수형으로 저장이 된다.
// 크기 : 1바이트(-2^7 ~ 2^7 -1) ... 127
// 유니코드 
// - UTF-8 (영어 : 1바이트, 한국어,중국어 : 3바이트)
// - UTF-16 (영어 : 2바이트, 한국어, 중국어 : 2바이트)
char aChar = 98;

// 실수형 (부동소수점 : 소수점이 부유하듯이 움직인다.)
// float (4바이트)
// [부호부 : 1비트][지수부: 8비트][유효숫자부 : 23비트]
// 0.5 : 1.0 x 2^-1
// [0][-1][23 x 0]
// [0][-1 + 127][23x0]
// 
// double
// 8바이트 

// 논리형
// bool
// 크기 : 1바이트? 울며 겨자먹기
// => 컴퓨터가 한번에 처리할 수 있는 최소단위 : 1바이트
// 0이면 false, 0아니면 true

// 사용자 정의 자료형
// struct : 복합 자료형

struct Vector
{
	__int64 x;
	int y;
	int padding; // 패딩바이트
	__int64 z;
};
// 24바이트

// 전역변수
int dInt = 0x1010;
int eInt = 5;

int main()
{
	// stack에서 초기화가 안되어있으면 쓰레기 값 => cc cc cc cc

	// 2진법 : 0b
	// 16진법 : 0x

	// main의 지역변수 : aInt, bInt, cInt
	// 정수형 오버플로우
	aShort = -32768;
	aShort -= 1;
	cout << aShort << endl;
	cout << aChar << endl;

	float aFloat = 0.5f;

	Vector v;
	v.x = 1;
	v.y = 2;
	v.z = 3;
	cout << "v의 크기: " << sizeof(v) << endl;

	return 0;
}